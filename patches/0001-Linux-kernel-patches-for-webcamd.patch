From 14bfb12565174b1401e743aabd4b62000cbd8c7c Mon Sep 17 00:00:00 2001
From: Hans Petter Selasky <hps@selasky.org>
Date: Wed, 2 Dec 2020 17:58:37 +0100
Subject: [PATCH 1/2] Linux kernel patches for webcamd.

Signed-off-by: Hans Petter Selasky <hps@selasky.org>
---
 drivers/base/regmap/regmap.c                  |  5 ++-
 drivers/hid/hid-asus.c                        |  7 ++--
 drivers/hid/hid-core.c                        |  7 +++-
 drivers/hid/hid-multitouch.c                  |  6 ++--
 drivers/hid/wacom.h                           |  1 +
 drivers/input/evdev.c                         |  2 +-
 drivers/input/tablet/aiptek.c                 |  2 +-
 drivers/leds/led-core.c                       | 12 +++++++
 .../media/common/videobuf2/videobuf2-core.c   |  8 +++--
 .../media/common/videobuf2/videobuf2-memops.c |  4 +++
 .../common/videobuf2/videobuf2-vmalloc.c      |  5 +++
 drivers/media/dvb-core/dvb_frontend.c         |  3 ++
 drivers/media/dvb-frontends/cx24120.c         |  2 ++
 drivers/media/dvb-frontends/cx24123.c         |  2 ++
 drivers/media/dvb-frontends/m88rs2000.c       |  1 +
 drivers/media/dvb-frontends/tda18271c2dd.c    |  4 +--
 drivers/media/i2c/adv7343.c                   |  4 +++
 drivers/media/i2c/tvp514x.c                   |  6 ++++
 drivers/media/i2c/tvp5150.c                   | 23 +++++++++++--
 drivers/media/i2c/tvp7002.c                   |  6 ++++
 drivers/media/rc/lirc_dev.c                   |  2 ++
 drivers/media/rc/rc-main.c                    | 15 +++++++++
 drivers/media/usb/as102/as102_drv.h           |  4 +--
 drivers/media/usb/cx231xx/cx231xx-i2c.c       |  1 +
 drivers/media/usb/dvb-usb-v2/lmedm04.c        |  1 +
 drivers/media/usb/dvb-usb-v2/usb_urb.c        | 21 +++++++++++-
 drivers/media/usb/dvb-usb/usb-urb.c           | 16 ++++++++++
 drivers/media/usb/em28xx/em28xx.h             |  1 +
 drivers/media/usb/gspca/gspca.c               |  2 +-
 drivers/media/usb/stkwebcam/stk-webcam.h      |  4 +--
 drivers/media/usb/uvc/uvc_driver.c            |  8 -----
 drivers/media/usb/uvc/uvc_video.c             | 22 ++++++++++---
 drivers/media/usb/uvc/uvcvideo.h              |  4 +--
 drivers/media/v4l2-core/v4l2-async.c          |  6 ++++
 drivers/media/v4l2-core/v4l2-dev.c            | 32 +++++++++++++++++++
 drivers/media/v4l2-core/v4l2-ioctl.c          |  2 ++
 drivers/media/v4l2-core/v4l2-subdev.c         |  3 +-
 include/media/v4l2-device.h                   |  2 ++
 include/uapi/asm-generic/ioctl.h              |  1 +
 include/uapi/linux/dvb/ca.h                   |  8 +++++
 include/uapi/linux/dvb/frontend.h             |  3 +-
 include/uapi/linux/input.h                    | 18 +++++++----
 42 files changed, 240 insertions(+), 46 deletions(-)

diff --git a/drivers/base/regmap/regmap.c b/drivers/base/regmap/regmap.c
index 5db536ccfcd6..af225d688547 100644
--- a/drivers/base/regmap/regmap.c
+++ b/drivers/base/regmap/regmap.c
@@ -663,7 +663,9 @@ enum regmap_endian regmap_get_val_endian(struct device *dev,
 					 const struct regmap_bus *bus,
 					 const struct regmap_config *config)
 {
+#if IS_ENABLED(CONFIG_OF)
 	struct fwnode_handle *fwnode = dev ? dev_fwnode(dev) : NULL;
+#endif
 	enum regmap_endian endian;
 
 	/* Retrieve the endianness specification from the regmap config */
@@ -673,6 +675,7 @@ enum regmap_endian regmap_get_val_endian(struct device *dev,
 	if (endian != REGMAP_ENDIAN_DEFAULT)
 		return endian;
 
+#if IS_ENABLED(CONFIG_OF)
 	/* If the firmware node exist try to get endianness from it */
 	if (fwnode_property_read_bool(fwnode, "big-endian"))
 		endian = REGMAP_ENDIAN_BIG;
@@ -680,7 +683,7 @@ enum regmap_endian regmap_get_val_endian(struct device *dev,
 		endian = REGMAP_ENDIAN_LITTLE;
 	else if (fwnode_property_read_bool(fwnode, "native-endian"))
 		endian = REGMAP_ENDIAN_NATIVE;
-
+#endif
 	/* If the endianness was specified in fwnode, use that */
 	if (endian != REGMAP_ENDIAN_DEFAULT)
 		return endian;
diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index c183caf89d49..9e72c7d6515f 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -439,12 +439,10 @@ static void asus_kbd_backlight_work(struct work_struct *work)
  */
 static bool asus_kbd_wmi_led_control_present(struct hid_device *hdev)
 {
+#if IS_ENABLED(CONFIG_ASUS_WMI)
 	u32 value;
 	int ret;
 
-	if (!IS_ENABLED(CONFIG_ASUS_WMI))
-		return false;
-
 	ret = asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS,
 				       ASUS_WMI_DEVID_KBD_BACKLIGHT, 0, &value);
 	hid_dbg(hdev, "WMI backlight check: rc %d value %x", ret, value);
@@ -452,6 +450,9 @@ static bool asus_kbd_wmi_led_control_present(struct hid_device *hdev)
 		return false;
 
 	return !!(value & ASUS_WMI_DSTS_PRESENCE_BIT);
+#else
+	return false;
+#endif
 }
 
 static int asus_kbd_register_leds(struct hid_device *hdev)
diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c
index 56172fe6995c..ef919739f4aa 100644
--- a/drivers/hid/hid-core.c
+++ b/drivers/hid/hid-core.c
@@ -2506,7 +2506,7 @@ void hid_destroy_device(struct hid_device *hdev)
 }
 EXPORT_SYMBOL_GPL(hid_destroy_device);
 
-
+#if 0
 static int __hid_bus_reprobe_drivers(struct device *dev, void *data)
 {
 	struct hid_driver *hdrv = data;
@@ -2536,6 +2536,7 @@ static int __bus_removed_driver(struct device_driver *drv, void *data)
 {
 	return bus_rescan_devices(&hid_bus_type);
 }
+#endif
 
 int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
 		const char *mod_name)
@@ -2552,9 +2553,11 @@ int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
 
 	ret = driver_register(&hdrv->driver);
 
+#if 0
 	if (ret == 0)
 		bus_for_each_drv(&hid_bus_type, NULL, NULL,
 				 __hid_bus_driver_added);
+#endif
 
 	return ret;
 }
@@ -2565,7 +2568,9 @@ void hid_unregister_driver(struct hid_driver *hdrv)
 	driver_unregister(&hdrv->driver);
 	hid_free_dynids(hdrv);
 
+#if 0
 	bus_for_each_drv(&hid_bus_type, NULL, hdrv, __bus_removed_driver);
+#endif
 }
 EXPORT_SYMBOL_GPL(hid_unregister_driver);
 
diff --git a/drivers/hid/hid-multitouch.c b/drivers/hid/hid-multitouch.c
index d670bcd57bde..f8423ca8f402 100644
--- a/drivers/hid/hid-multitouch.c
+++ b/drivers/hid/hid-multitouch.c
@@ -129,7 +129,7 @@ struct mt_application {
 				 */
 
 	__s32 dev_time;		/* the scan time provided by the device */
-	unsigned long jiffies;	/* the frame's jiffies */
+	unsigned long jfs;	/* the frame's jiffies */
 	int timestamp;		/* the timestamp to be sent */
 	int prev_scantime;		/* scantime reported previously */
 
@@ -941,9 +941,9 @@ static void mt_sync_frame(struct mt_device *td, struct mt_application *app,
 static int mt_compute_timestamp(struct mt_application *app, __s32 value)
 {
 	long delta = value - app->prev_scantime;
-	unsigned long jdelta = jiffies_to_usecs(jiffies - app->jiffies);
+	unsigned long jdelta = jiffies_to_usecs(jiffies - app->jfs);
 
-	app->jiffies = jiffies;
+	app->jfs = jiffies;
 
 	if (delta < 0)
 		delta += app->scantime_logical_max;
diff --git a/drivers/hid/wacom.h b/drivers/hid/wacom.h
index 203d27d198b8..463efcad9c5b 100644
--- a/drivers/hid/wacom.h
+++ b/drivers/hid/wacom.h
@@ -91,6 +91,7 @@
 #include <linux/leds.h>
 #include <linux/usb/input.h>
 #include <linux/power_supply.h>
+#include <linux/string.h>
 #include <asm/unaligned.h>
 
 /*
diff --git a/drivers/input/evdev.c b/drivers/input/evdev.c
index 95f90699d2b1..c0fde2b92bd5 100644
--- a/drivers/input/evdev.c
+++ b/drivers/input/evdev.c
@@ -766,7 +766,7 @@ static int str_to_user(const char *str, unsigned int maxlen, void __user *p)
 	int len;
 
 	if (!str)
-		return -ENOENT;
+		str = "";
 
 	len = strlen(str) + 1;
 	if (len > maxlen)
diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index e08b0ef078e8..0913ba09712a 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1355,7 +1355,7 @@ static ssize_t show_tabletDiagnosticMessage(struct device *dev, struct device_at
 	default:
 		return 0;
 	}
-	return snprintf(buf, PAGE_SIZE, retMsg);
+	return snprintf(buf, PAGE_SIZE, "%s", retMsg);
 }
 
 static DEVICE_ATTR(diagnostic, S_IRUGO, show_tabletDiagnosticMessage, NULL);
diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index c4e780bdb385..e639be242817 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -326,6 +326,7 @@ EXPORT_SYMBOL_GPL(led_update_brightness);
 
 u32 *led_get_default_pattern(struct led_classdev *led_cdev, unsigned int *size)
 {
+#if IS_ENABLED(CONFIG_OF)
 	struct fwnode_handle *fwnode = led_cdev->dev->fwnode;
 	u32 *pattern;
 	int count;
@@ -346,6 +347,9 @@ u32 *led_get_default_pattern(struct led_classdev *led_cdev, unsigned int *size)
 	*size = count;
 
 	return pattern;
+#else
+	return NULL;
+#endif
 }
 EXPORT_SYMBOL_GPL(led_get_default_pattern);
 
@@ -367,6 +371,7 @@ void led_sysfs_enable(struct led_classdev *led_cdev)
 }
 EXPORT_SYMBOL_GPL(led_sysfs_enable);
 
+#if IS_ENABLED(CONFIG_OF)
 static void led_parse_fwnode_props(struct device *dev,
 				   struct fwnode_handle *fwnode,
 				   struct led_properties *props)
@@ -417,12 +422,15 @@ static void led_parse_fwnode_props(struct device *dev,
 		props->func_enum_present = true;
 	}
 }
+#endif
 
 int led_compose_name(struct device *dev, struct led_init_data *init_data,
 		     char *led_classdev_name)
 {
 	struct led_properties props = {};
+#if IS_ENABLED(CONFIG_OF)
 	struct fwnode_handle *fwnode = init_data->fwnode;
+#endif
 	const char *devicename = init_data->devicename;
 
 	/* We want to label LEDs that can produce full range of colors
@@ -432,7 +440,9 @@ int led_compose_name(struct device *dev, struct led_init_data *init_data,
 	if (!led_classdev_name)
 		return -EINVAL;
 
+#if IS_ENABLED(CONFIG_OF)
 	led_parse_fwnode_props(dev, fwnode, &props);
+#endif
 
 	if (props.label) {
 		/*
@@ -474,9 +484,11 @@ int led_compose_name(struct device *dev, struct led_init_data *init_data,
 		}
 		snprintf(led_classdev_name, LED_MAX_NAME_SIZE, "%s:%s",
 			 devicename, init_data->default_label);
+#if IS_ENABLED(CONFIG_OF)
 	} else if (is_of_node(fwnode)) {
 		strscpy(led_classdev_name, to_of_node(fwnode)->name,
 			LED_MAX_NAME_SIZE);
+#endif
 	} else
 		return -EINVAL;
 
diff --git a/drivers/media/common/videobuf2/videobuf2-core.c b/drivers/media/common/videobuf2/videobuf2-core.c
index 4eab6d81cce1..007a91b9476a 100644
--- a/drivers/media/common/videobuf2/videobuf2-core.c
+++ b/drivers/media/common/videobuf2/videobuf2-core.c
@@ -678,7 +678,7 @@ static int __verify_dmabuf_ops(struct vb2_queue *q)
 int vb2_verify_memory_type(struct vb2_queue *q,
 		enum vb2_memory memory, unsigned int type)
 {
-	if (memory != VB2_MEMORY_MMAP && memory != VB2_MEMORY_USERPTR &&
+	if (memory != VB2_MEMORY_MMAP && /* memory != VB2_MEMORY_USERPTR && */
 	    memory != VB2_MEMORY_DMABUF) {
 		dprintk(q, 1, "unsupported memory type\n");
 		return -EINVAL;
@@ -697,12 +697,12 @@ int vb2_verify_memory_type(struct vb2_queue *q,
 		dprintk(q, 1, "MMAP for current setup unsupported\n");
 		return -EINVAL;
 	}
-
+#if 0
 	if (memory == VB2_MEMORY_USERPTR && __verify_userptr_ops(q)) {
 		dprintk(q, 1, "USERPTR for current setup unsupported\n");
 		return -EINVAL;
 	}
-
+#endif
 	if (memory == VB2_MEMORY_DMABUF && __verify_dmabuf_ops(q)) {
 		dprintk(q, 1, "DMABUF for current setup unsupported\n");
 		return -EINVAL;
@@ -1352,9 +1352,11 @@ static int __buf_prepare(struct vb2_buffer *vb)
 	case VB2_MEMORY_MMAP:
 		ret = __prepare_mmap(vb);
 		break;
+#if 0
 	case VB2_MEMORY_USERPTR:
 		ret = __prepare_userptr(vb);
 		break;
+#endif
 	case VB2_MEMORY_DMABUF:
 		ret = __prepare_dmabuf(vb);
 		break;
diff --git a/drivers/media/common/videobuf2/videobuf2-memops.c b/drivers/media/common/videobuf2/videobuf2-memops.c
index 6e9e05153f4e..847f90bab5ab 100644
--- a/drivers/media/common/videobuf2/videobuf2-memops.c
+++ b/drivers/media/common/videobuf2/videobuf2-memops.c
@@ -22,6 +22,7 @@
 #include <media/videobuf2-v4l2.h>
 #include <media/videobuf2-memops.h>
 
+#if 0
 /**
  * vb2_create_framevec() - map virtual addresses to pfns
  * @start:	Virtual user address where we start mapping
@@ -64,7 +65,9 @@ struct frame_vector *vb2_create_framevec(unsigned long start,
 	return ERR_PTR(ret);
 }
 EXPORT_SYMBOL(vb2_create_framevec);
+#endif
 
+#if 0
 /**
  * vb2_destroy_framevec() - release vector of mapped pfns
  * @vec:	vector of pfns / pages to release
@@ -78,6 +81,7 @@ void vb2_destroy_framevec(struct frame_vector *vec)
 	frame_vector_destroy(vec);
 }
 EXPORT_SYMBOL(vb2_destroy_framevec);
+#endif
 
 /**
  * vb2_common_vm_open() - increase refcount of the vma
diff --git a/drivers/media/common/videobuf2/videobuf2-vmalloc.c b/drivers/media/common/videobuf2/videobuf2-vmalloc.c
index bf5ac63a5742..8cd1af055d57 100644
--- a/drivers/media/common/videobuf2/videobuf2-vmalloc.c
+++ b/drivers/media/common/videobuf2/videobuf2-vmalloc.c
@@ -71,6 +71,7 @@ static void vb2_vmalloc_put(void *buf_priv)
 	}
 }
 
+#if 0
 static void *vb2_vmalloc_get_userptr(struct device *dev, unsigned long vaddr,
 				     unsigned long size,
 				     enum dma_data_direction dma_dir)
@@ -146,6 +147,10 @@ static void vb2_vmalloc_put_userptr(void *buf_priv)
 	vb2_destroy_framevec(buf->vec);
 	kfree(buf);
 }
+#else
+#define	vb2_vmalloc_get_userptr NULL
+#define	vb2_vmalloc_put_userptr NULL
+#endif
 
 static void *vb2_vmalloc_vaddr(void *buf_priv)
 {
diff --git a/drivers/media/dvb-core/dvb_frontend.c b/drivers/media/dvb-core/dvb_frontend.c
index 06ea30a689d7..7c381958412d 100644
--- a/drivers/media/dvb-core/dvb_frontend.c
+++ b/drivers/media/dvb-core/dvb_frontend.c
@@ -2015,6 +2015,8 @@ static int dvb_frontend_do_ioctl(struct file *file, unsigned int cmd,
 	 * reading from them would interfere with a DVB tune application
 	 */
 	if ((file->f_flags & O_ACCMODE) == O_RDONLY
+	    && (cmd != FE_GET_PROPERTY)
+	    && (cmd != FE_GET_PROPERTY_OLD)
 	    && (_IOC_DIR(cmd) != _IOC_READ
 		|| cmd == FE_GET_EVENT
 		|| cmd == FE_DISEQC_RECV_SLAVE_REPLY)) {
@@ -2431,6 +2433,7 @@ static int dvb_frontend_handle_ioctl(struct file *file,
 		err = 0;
 		break;
 	}
+	case FE_GET_PROPERTY_OLD:
 	case FE_GET_PROPERTY:
 		err = dvb_get_property(fe, file, parg);
 		break;
diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 2464b63fe0cf..658a3ac1b408 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -103,6 +103,8 @@ enum command_message_id {
 #define CX24120_BER_WINDOW	16
 #define CX24120_BER_WSIZE	((1 << CX24120_BER_WINDOW) * 208 * 8)
 
+#undef info
+#undef err
 #define info(args...) pr_info("cx24120: " args)
 #define err(args...)  pr_err("cx24120: ### ERROR: " args)
 
diff --git a/drivers/media/dvb-frontends/cx24123.c b/drivers/media/dvb-frontends/cx24123.c
index 3d84ee17e54c..4f5efe9dbc5e 100644
--- a/drivers/media/dvb-frontends/cx24123.c
+++ b/drivers/media/dvb-frontends/cx24123.c
@@ -29,6 +29,8 @@ static int debug;
 module_param(debug, int, 0644);
 MODULE_PARM_DESC(debug, "Activates frontend debugging (default:0)");
 
+#undef info
+#undef err
 #define info(args...) do { printk(KERN_INFO "CX24123: " args); } while (0)
 #define err(args...)  do { printk(KERN_ERR  "CX24123: " args); } while (0)
 
diff --git a/drivers/media/dvb-frontends/m88rs2000.c b/drivers/media/dvb-frontends/m88rs2000.c
index 39cbb3ea1c9d..cd171c46c710 100644
--- a/drivers/media/dvb-frontends/m88rs2000.c
+++ b/drivers/media/dvb-frontends/m88rs2000.c
@@ -45,6 +45,7 @@ MODULE_PARM_DESC(debug, "set debugging level (1=info (or-able)).");
 } while (0)
 
 #define deb_info(args...)  dprintk(0x01, args)
+#undef info
 #define info(format, arg...) \
 	printk(KERN_INFO "m88rs2000-fe: " format "\n" , ## arg)
 
diff --git a/drivers/media/dvb-frontends/tda18271c2dd.c b/drivers/media/dvb-frontends/tda18271c2dd.c
index a34834487943..2a7d7e80ca49 100644
--- a/drivers/media/dvb-frontends/tda18271c2dd.c
+++ b/drivers/media/dvb-frontends/tda18271c2dd.c
@@ -1091,7 +1091,7 @@ static int ChannelConfiguration(struct tda_state *state,
 	return status;
 }
 
-static int sleep(struct dvb_frontend *fe)
+static int do_sleep(struct dvb_frontend *fe)
 {
 	struct tda_state *state = fe->tuner_priv;
 
@@ -1203,7 +1203,7 @@ static const struct dvb_tuner_ops tuner_ops = {
 		.frequency_step_hz =  62500
 	},
 	.init              = init,
-	.sleep             = sleep,
+	.sleep             = do_sleep,
 	.set_params        = set_params,
 	.release           = release,
 	.get_if_frequency  = get_if_frequency,
diff --git a/drivers/media/i2c/adv7343.c b/drivers/media/i2c/adv7343.c
index 63e94dfcb5d3..667aba0894cd 100644
--- a/drivers/media/i2c/adv7343.c
+++ b/drivers/media/i2c/adv7343.c
@@ -397,6 +397,7 @@ static int adv7343_initialize(struct v4l2_subdev *sd)
 static struct adv7343_platform_data *
 adv7343_get_pdata(struct i2c_client *client)
 {
+#if IS_ENABLED(CONFIG_OF)
 	struct adv7343_platform_data *pdata;
 	struct device_node *np;
 
@@ -426,6 +427,9 @@ adv7343_get_pdata(struct i2c_client *client)
 done:
 	of_node_put(np);
 	return pdata;
+#else
+	return client->dev.platform_data;
+#endif
 }
 
 static int adv7343_probe(struct i2c_client *client)
diff --git a/drivers/media/i2c/tvp514x.c b/drivers/media/i2c/tvp514x.c
index a7fbe5b400c2..1893aeedc336 100644
--- a/drivers/media/i2c/tvp514x.c
+++ b/drivers/media/i2c/tvp514x.c
@@ -979,6 +979,7 @@ static const struct tvp514x_decoder tvp514x_dev = {
 static struct tvp514x_platform_data *
 tvp514x_get_pdata(struct i2c_client *client)
 {
+#if IS_ENABLED(CONFIG_OF)
 	struct tvp514x_platform_data *pdata = NULL;
 	struct v4l2_fwnode_endpoint bus_cfg = { .bus_type = 0 };
 	struct device_node *endpoint;
@@ -1012,6 +1013,9 @@ tvp514x_get_pdata(struct i2c_client *client)
 done:
 	of_node_put(endpoint);
 	return pdata;
+#else
+	return client->dev.platform_data;
+#endif
 }
 
 /**
@@ -1206,7 +1210,9 @@ MODULE_DEVICE_TABLE(of, tvp514x_of_match);
 
 static struct i2c_driver tvp514x_driver = {
 	.driver = {
+#if IS_ENABLED(CONFIG_OF)
 		.of_match_table = of_match_ptr(tvp514x_of_match),
+#endif
 		.name = TVP514X_MODULE_NAME,
 	},
 	.probe = tvp514x_probe,
diff --git a/drivers/media/i2c/tvp5150.c b/drivers/media/i2c/tvp5150.c
index 7d9401219a3a..1a6c8c5fe4d1 100644
--- a/drivers/media/i2c/tvp5150.c
+++ b/drivers/media/i2c/tvp5150.c
@@ -1996,6 +1996,7 @@ static int tvp5150_validate_connectors(struct tvp5150 *decoder)
 	return 0;
 }
 
+#if IS_ENABLED(CONFIG_OF)
 static int tvp5150_parse_dt(struct tvp5150 *decoder, struct device_node *np)
 {
 	struct device *dev = decoder->sd.dev;
@@ -2106,11 +2107,13 @@ static int tvp5150_parse_dt(struct tvp5150 *decoder, struct device_node *np)
 err_put:
 	of_node_put(ep_np);
 err_free:
+#if IS_ENABLED(CONFIG_OF)
 	for (i = 0; i < TVP5150_MAX_CONNECTORS; i++)
 		v4l2_fwnode_connector_free(&decoder->connectors[i].base);
-
+#endif
 	return ret;
 }
+#endif
 
 static const char * const tvp5150_test_patterns[2] = {
 	"Disabled",
@@ -2121,7 +2124,9 @@ static int tvp5150_probe(struct i2c_client *c)
 {
 	struct tvp5150 *core;
 	struct v4l2_subdev *sd;
+#if IS_ENABLED(CONFIG_OF)
 	struct device_node *np = c->dev.of_node;
+#endif
 	struct regmap *map;
 	unsigned int i;
 	int res;
@@ -2149,7 +2154,8 @@ static int tvp5150_probe(struct i2c_client *c)
 	sd->internal_ops = &tvp5150_internal_ops;
 	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
 
-	if (IS_ENABLED(CONFIG_OF) && np) {
+#if IS_ENABLED(CONFIG_OF)
+	if (np) {
 		res = tvp5150_parse_dt(core, np);
 		if (res) {
 			dev_err(sd->dev, "DT parsing error: %d\n", res);
@@ -2159,6 +2165,10 @@ static int tvp5150_probe(struct i2c_client *c)
 		/* Default to BT.656 embedded sync */
 		core->mbus_type = V4L2_MBUS_BT656;
 	}
+#else
+	/* Default to BT.656 embedded sync */
+	core->mbus_type = V4L2_MBUS_BT656;
+#endif
 
 	res = tvp5150_mc_init(core);
 	if (res)
@@ -2214,11 +2224,16 @@ static int tvp5150_probe(struct i2c_client *c)
 	core->irq = c->irq;
 	tvp5150_reset(sd, 0);	/* Calls v4l2_ctrl_handler_setup() */
 	if (c->irq) {
+#if 0
 		res = devm_request_threaded_irq(&c->dev, c->irq, NULL,
 						tvp5150_isr, IRQF_TRIGGER_HIGH |
 						IRQF_ONESHOT, "tvp5150", core);
 		if (res)
 			goto err;
+#else
+		res = -EINVAL;
+		goto err;
+#endif
 	}
 
 	res = v4l2_async_register_subdev(sd);
@@ -2249,12 +2264,16 @@ static int tvp5150_remove(struct i2c_client *c)
 		"tvp5150.c: removing tvp5150 adapter on address 0x%x\n",
 		c->addr << 1);
 
+#if IS_ENABLED(CONFIG_OF)
 	for (i = 0; i < decoder->connectors_num; i++)
 		v4l2_fwnode_connector_free(&decoder->connectors[i].base);
+#endif
+#if defined(CONFIG_MEDIA_CONTROLLER)
 	for (i = 0; i < decoder->connectors_num; i++) {
 		media_device_unregister_entity(&decoder->connectors[i].ent);
 		media_entity_cleanup(&decoder->connectors[i].ent);
 	}
+#endif
 	v4l2_async_unregister_subdev(sd);
 	v4l2_ctrl_handler_free(&decoder->hdl);
 	pm_runtime_disable(&c->dev);
diff --git a/drivers/media/i2c/tvp7002.c b/drivers/media/i2c/tvp7002.c
index ada4ec5ef782..a46d93d8bf39 100644
--- a/drivers/media/i2c/tvp7002.c
+++ b/drivers/media/i2c/tvp7002.c
@@ -882,6 +882,7 @@ static const struct v4l2_subdev_ops tvp7002_ops = {
 static struct tvp7002_config *
 tvp7002_get_pdata(struct i2c_client *client)
 {
+#if IS_ENABLED(CONFIG_OF)
 	struct v4l2_fwnode_endpoint bus_cfg = { .bus_type = 0 };
 	struct tvp7002_config *pdata = NULL;
 	struct device_node *endpoint;
@@ -921,6 +922,9 @@ tvp7002_get_pdata(struct i2c_client *client)
 done:
 	of_node_put(endpoint);
 	return pdata;
+#else
+	return client->dev.platform_data;
+#endif
 }
 
 /*
@@ -1074,7 +1078,9 @@ MODULE_DEVICE_TABLE(of, tvp7002_of_match);
 /* I2C driver data */
 static struct i2c_driver tvp7002_driver = {
 	.driver = {
+#if IS_ENABLED(CONFIG_OF)
 		.of_match_table = of_match_ptr(tvp7002_of_match),
+#endif
 		.name = TVP7002_MODULE_NAME,
 	},
 	.probe_new = tvp7002_probe,
diff --git a/drivers/media/rc/lirc_dev.c b/drivers/media/rc/lirc_dev.c
index 220363b9a868..54c2b5ebab74 100644
--- a/drivers/media/rc/lirc_dev.c
+++ b/drivers/media/rc/lirc_dev.c
@@ -822,6 +822,7 @@ void __exit lirc_dev_exit(void)
 	unregister_chrdev_region(lirc_base_dev, RC_DEV_MAX);
 }
 
+#if 0
 struct rc_dev *rc_dev_get_from_fd(int fd)
 {
 	struct fd f = fdget(fd);
@@ -844,5 +845,6 @@ struct rc_dev *rc_dev_get_from_fd(int fd)
 
 	return dev;
 }
+#endif
 
 MODULE_ALIAS("lirc_dev");
diff --git a/drivers/media/rc/rc-main.c b/drivers/media/rc/rc-main.c
index 1d811e5ffb55..aa5f9dbb082e 100644
--- a/drivers/media/rc/rc-main.c
+++ b/drivers/media/rc/rc-main.c
@@ -1887,6 +1887,12 @@ static void rc_free_rx_device(struct rc_dev *dev)
 	ir_free_table(&dev->rc_map);
 }
 
+static char *rc_core_default_protocol;
+module_param_named(default_protocol, rc_core_default_protocol, charp, 0644);
+MODULE_PARM_DESC(default_protocol, "Select default protocol: "
+    "jvc, lirc, mce_kbd, nec, none, other, rc-5, rc-5-sz, "
+    "rc-6, sanyo, sharp, sony, unknown or xmp");
+
 int rc_register_device(struct rc_dev *dev)
 {
 	const char *path;
@@ -1966,6 +1972,15 @@ int rc_register_device(struct rc_dev *dev)
 	dev_dbg(&dev->dev, "Registered rc%u (driver: %s)\n", dev->minor,
 		dev->driver_name ? dev->driver_name : "unknown");
 
+	if (rc_core_default_protocol != NULL) {
+		/* set initial default protocol */
+		if (store_protocols(&dev->dev, &dev_attr_protocols,
+		    rc_core_default_protocol,
+		    strlen(rc_core_default_protocol)) < 0) {
+			printk(KERN_ERR "Could not store protocol '%s'\n",
+			    rc_core_default_protocol);
+		}
+	}
 	return 0;
 
 out_rx:
diff --git a/drivers/media/usb/as102/as102_drv.h b/drivers/media/usb/as102/as102_drv.h
index 4342c7ce3407..a790077b44a5 100644
--- a/drivers/media/usb/as102/as102_drv.h
+++ b/drivers/media/usb/as102/as102_drv.h
@@ -23,8 +23,8 @@ extern int elna_enable;
 
 #define AS102_DEVICE_MAJOR	192
 
-#define AS102_USB_BUF_SIZE	512
-#define MAX_STREAM_URB		32
+#define AS102_USB_BUF_SIZE	(1 << 14)
+#define MAX_STREAM_URB		2
 
 struct as10x_bus_adapter_t {
 	struct usb_device *usb_dev;
diff --git a/drivers/media/usb/cx231xx/cx231xx-i2c.c b/drivers/media/usb/cx231xx/cx231xx-i2c.c
index c6659253c6fb..0ed246b01cca 100644
--- a/drivers/media/usb/cx231xx/cx231xx-i2c.c
+++ b/drivers/media/usb/cx231xx/cx231xx-i2c.c
@@ -593,6 +593,7 @@ struct i2c_adapter *cx231xx_get_i2c_adap(struct cx231xx *dev, int i2c_port)
 		return dev->muxc->adapter[1];
 	default:
 		BUG();
+		return NULL;
 	}
 }
 EXPORT_SYMBOL_GPL(cx231xx_get_i2c_adap);
diff --git a/drivers/media/usb/dvb-usb-v2/lmedm04.c b/drivers/media/usb/dvb-usb-v2/lmedm04.c
index 5a7a9522d46d..c9107d7018e9 100644
--- a/drivers/media/usb/dvb-usb-v2/lmedm04.c
+++ b/drivers/media/usb/dvb-usb-v2/lmedm04.c
@@ -86,6 +86,7 @@ static int dvb_usb_lme2510_debug;
 #define deb_info(level, args...) lme_debug(dvb_usb_lme2510_debug, level, args)
 #define debug_data_snipet(level, name, p) \
 	 deb_info(level, name" (%8phN)", p);
+#undef info
 #define info(args...) pr_info(DVB_USB_LOG_PREFIX": "args)
 
 module_param_named(debug, dvb_usb_lme2510_debug, int, 0644);
diff --git a/drivers/media/usb/dvb-usb-v2/usb_urb.c b/drivers/media/usb/dvb-usb-v2/usb_urb.c
index 2ad2ddeaff51..542c01844d13 100644
--- a/drivers/media/usb/dvb-usb-v2/usb_urb.c
+++ b/drivers/media/usb/dvb-usb-v2/usb_urb.c
@@ -250,6 +250,7 @@ static int usb_alloc_stream_buffers(struct usb_data_stream *stream, int num,
 int usb_urb_reconfig(struct usb_data_stream *stream,
 		struct usb_data_stream_properties *props)
 {
+#if 0
 	int buf_size;
 
 	if (!props)
@@ -299,7 +300,7 @@ int usb_urb_reconfig(struct usb_data_stream *stream,
 		return usb_urb_alloc_bulk_urbs(stream);
 	else if (props->type == USB_ISOC)
 		return usb_urb_alloc_isoc_urbs(stream);
-
+#endif
 	return 0;
 }
 
@@ -322,6 +323,11 @@ int usb_urb_initv2(struct usb_data_stream *stream,
 
 	switch (stream->props.type) {
 	case USB_BULK:
+
+		/* XXX override driver parameters */
+		stream->props.count = 2;
+		if (stream->props.u.bulk.buffersize < 131072)
+			stream->props.u.bulk.buffersize = 131072;
 		ret = usb_alloc_stream_buffers(stream, stream->props.count,
 				stream->props.u.bulk.buffersize);
 		if (ret < 0)
@@ -329,6 +335,19 @@ int usb_urb_initv2(struct usb_data_stream *stream,
 
 		return usb_urb_alloc_bulk_urbs(stream);
 	case USB_ISOC:
+
+		/* XXX override driver parameters */
+		switch (stream->udev->speed) {
+		case USB_SPEED_FULL:
+		case USB_SPEED_LOW:
+			stream->props.count = 2;
+			stream->props.u.isoc.framesperurb = 24;
+			break;
+		default:
+			stream->props.count = 2;
+			stream->props.u.isoc.framesperurb = 24 * 8;
+			break;
+		}
 		ret = usb_alloc_stream_buffers(stream, stream->props.count,
 				stream->props.u.isoc.framesize *
 				stream->props.u.isoc.framesperurb);
diff --git a/drivers/media/usb/dvb-usb/usb-urb.c b/drivers/media/usb/dvb-usb/usb-urb.c
index 9771f0954c69..1fe83a6bcf12 100644
--- a/drivers/media/usb/dvb-usb/usb-urb.c
+++ b/drivers/media/usb/dvb-usb/usb-urb.c
@@ -226,8 +226,24 @@ int usb_urb_init(struct usb_data_stream *stream, struct usb_data_stream_properti
 
 	switch (stream->props.type) {
 		case USB_BULK:
+			/* XXX override driver parameters */
+			stream->props.count = 2;
+			if (stream->props.u.bulk.buffersize < 131072)
+				stream->props.u.bulk.buffersize = 131072;
 			return usb_bulk_urb_init(stream);
 		case USB_ISOC:
+			/* XXX override driver parameters */
+			switch (stream->udev->speed) {
+			case USB_SPEED_FULL:
+			case USB_SPEED_LOW:
+				stream->props.count = 2;
+				stream->props.u.isoc.framesperurb = 24;
+				break;
+			default:
+				stream->props.count = 2;
+				stream->props.u.isoc.framesperurb = 24 * 8;
+				break;
+			}
 			return usb_isoc_urb_init(stream);
 		default:
 			err("unknown URB-type for data transfer.");
diff --git a/drivers/media/usb/em28xx/em28xx.h b/drivers/media/usb/em28xx/em28xx.h
index 55a46faaf7b7..f99895c0ef5e 100644
--- a/drivers/media/usb/em28xx/em28xx.h
+++ b/drivers/media/usb/em28xx/em28xx.h
@@ -454,6 +454,7 @@ enum em28xx_led_role {
 	EM28XX_LED_DIGITAL_CAPTURING_TS2,
 	EM28XX_LED_ILLUMINATION,
 	EM28XX_NUM_LED_ROLES, /* must be the last */
+	EM28XX_LED_DUMMY = -1,	/* force enum signed */
 };
 
 struct em28xx_led {
diff --git a/drivers/media/usb/gspca/gspca.c b/drivers/media/usb/gspca/gspca.c
index c295f642d352..0d9873d0392a 100644
--- a/drivers/media/usb/gspca/gspca.c
+++ b/drivers/media/usb/gspca/gspca.c
@@ -37,7 +37,7 @@
 #endif
 
 /* global values */
-#define DEF_NURBS 3		/* default number of URBs */
+#define DEF_NURBS 2		/* default number of URBs */
 #if DEF_NURBS > MAX_NURBS
 #error "DEF_NURBS too big"
 #endif
diff --git a/drivers/media/usb/stkwebcam/stk-webcam.h b/drivers/media/usb/stkwebcam/stk-webcam.h
index 14519e5308b1..e1ebdc9b4d7a 100644
--- a/drivers/media/usb/stkwebcam/stk-webcam.h
+++ b/drivers/media/usb/stkwebcam/stk-webcam.h
@@ -17,8 +17,8 @@
 #define DRIVER_VERSION		"v0.0.1"
 #define DRIVER_VERSION_NUM	0x000001
 
-#define MAX_ISO_BUFS		3
-#define ISO_FRAMES_PER_DESC	16
+#define MAX_ISO_BUFS		2
+#define ISO_FRAMES_PER_DESC	56
 #define ISO_MAX_FRAME_SIZE	3 * 1024
 #define ISO_BUFFER_SIZE		(ISO_FRAMES_PER_DESC * ISO_MAX_FRAME_SIZE)
 
diff --git a/drivers/media/usb/uvc/uvc_driver.c b/drivers/media/usb/uvc/uvc_driver.c
index ddb9eaa11be7..f35dfc8b1b49 100644
--- a/drivers/media/usb/uvc/uvc_driver.c
+++ b/drivers/media/usb/uvc/uvc_driver.c
@@ -2008,8 +2008,6 @@ static void uvc_unregister_video(struct uvc_device *dev)
 
 		video_unregister_device(&stream->vdev);
 		video_unregister_device(&stream->meta.vdev);
-
-		uvc_debugfs_cleanup_stream(stream);
 	}
 
 	uvc_status_unregister(dev);
@@ -2105,8 +2103,6 @@ static int uvc_register_video(struct uvc_device *dev,
 	else
 		stream->chain->caps |= V4L2_CAP_VIDEO_OUTPUT;
 
-	uvc_debugfs_init_stream(stream);
-
 	/* Register the device with V4L. */
 	return uvc_register_video_device(dev, stream, &stream->vdev,
 					 &stream->queue, stream->type,
@@ -2994,11 +2990,8 @@ static int __init uvc_init(void)
 {
 	int ret;
 
-	uvc_debugfs_init();
-
 	ret = usb_register(&uvc_driver.driver);
 	if (ret < 0) {
-		uvc_debugfs_cleanup();
 		return ret;
 	}
 
@@ -3009,7 +3002,6 @@ static int __init uvc_init(void)
 static void __exit uvc_cleanup(void)
 {
 	usb_deregister(&uvc_driver.driver);
-	uvc_debugfs_cleanup();
 }
 
 module_init(uvc_init);
diff --git a/drivers/media/usb/uvc/uvc_video.c b/drivers/media/usb/uvc/uvc_video.c
index a6a441d92b94..8cd3ea905550 100644
--- a/drivers/media/usb/uvc/uvc_video.c
+++ b/drivers/media/usb/uvc/uvc_video.c
@@ -1601,9 +1601,7 @@ static int uvc_alloc_urb_buffers(struct uvc_streaming *stream,
 	/* Compute the number of packets. Bulk endpoints might transfer UVC
 	 * payloads across multiple URBs.
 	 */
-	npackets = DIV_ROUND_UP(size, psize);
-	if (npackets > UVC_MAX_PACKETS)
-		npackets = UVC_MAX_PACKETS;
+	npackets = size / psize;
 
 	/* Retry allocations until one succeed. */
 	for (; npackets > 1; npackets /= 2) {
@@ -1709,7 +1707,23 @@ static int uvc_init_video_isoc(struct uvc_streaming *stream,
 	u32 size;
 
 	psize = uvc_endpoint_max_bpi(stream->dev->udev, ep);
-	size = stream->ctrl.dwMaxVideoFrameSize;
+
+	if (stream->dev->udev->speed == USB_SPEED_FULL) {
+		/* (8000 >> 3) = 1000 FPS */
+		size = (UVC_MAX_PACKETS >> 3) * psize;
+	} else {
+		/* 1000 - 8000 FPS, figure out */
+		size = ep->desc.bInterval;
+		if (size > 0)
+			size --;
+		if (size > 3)
+			size = 3;
+		size = (UVC_MAX_PACKETS >> size) * psize;
+	}
+
+	/* avoid division by zero */
+	if (psize == 0)
+		return -EINVAL;
 
 	npackets = uvc_alloc_urb_buffers(stream, size, psize, gfp_flags);
 	if (npackets == 0)
diff --git a/drivers/media/usb/uvc/uvcvideo.h b/drivers/media/usb/uvc/uvcvideo.h
index a3dfacf069c4..f75aae32f4a1 100644
--- a/drivers/media/usb/uvc/uvcvideo.h
+++ b/drivers/media/usb/uvc/uvcvideo.h
@@ -177,9 +177,9 @@
 #define DRIVER_VERSION		"1.1.1"
 
 /* Number of isochronous URBs. */
-#define UVC_URBS		5
+#define UVC_URBS		2U
 /* Maximum number of packets per URB. */
-#define UVC_MAX_PACKETS		32
+#define UVC_MAX_PACKETS		128U	/* at 8000 FPS */
 /* Maximum status buffer size in bytes of interrupt URB. */
 #define UVC_MAX_STATUS_SIZE	16
 
diff --git a/drivers/media/v4l2-core/v4l2-async.c b/drivers/media/v4l2-core/v4l2-async.c
index e3ab003a6c85..12c8a1b06d0f 100644
--- a/drivers/media/v4l2-core/v4l2-async.c
+++ b/drivers/media/v4l2-core/v4l2-async.c
@@ -73,6 +73,7 @@ static bool match_devname(struct v4l2_async_notifier *notifier,
 static bool match_fwnode(struct v4l2_async_notifier *notifier,
 			 struct v4l2_subdev *sd, struct v4l2_async_subdev *asd)
 {
+#if IS_ENABLED(CONFIG_OF)
 	struct fwnode_handle *other_fwnode;
 	struct fwnode_handle *dev_fwnode;
 	bool asd_fwnode_is_ep;
@@ -137,6 +138,9 @@ static bool match_fwnode(struct v4l2_async_notifier *notifier,
 	}
 
 	return true;
+#else
+	return false;
+#endif
 }
 
 static bool match_custom(struct v4l2_async_notifier *notifier,
@@ -587,6 +591,7 @@ __v4l2_async_notifier_unregister(struct v4l2_async_notifier *notifier)
 	list_del(&notifier->list);
 }
 
+#if 0
 void v4l2_async_notifier_unregister(struct v4l2_async_notifier *notifier)
 {
 	mutex_lock(&list_lock);
@@ -596,6 +601,7 @@ void v4l2_async_notifier_unregister(struct v4l2_async_notifier *notifier)
 	mutex_unlock(&list_lock);
 }
 EXPORT_SYMBOL(v4l2_async_notifier_unregister);
+#endif
 
 static void __v4l2_async_notifier_cleanup(struct v4l2_async_notifier *notifier)
 {
diff --git a/drivers/media/v4l2-core/v4l2-dev.c b/drivers/media/v4l2-core/v4l2-dev.c
index a593ea0598b5..3d166bc279b6 100644
--- a/drivers/media/v4l2-core/v4l2-dev.c
+++ b/drivers/media/v4l2-core/v4l2-dev.c
@@ -38,6 +38,16 @@
 } while (0)
 
 
+static int v4l_vflip;
+module_param(v4l_vflip, int, 0644);
+MODULE_PARM_DESC(v4l_vflip,
+	"Force all V4L devices to flip the picture vertically.");
+
+static int v4l_hflip;
+module_param(v4l_hflip, int, 0644);
+MODULE_PARM_DESC(v4l_hflip,
+	"Force all V4L devices to flip the picture horizontally.");
+
 /*
  *	sysfs stuff
  */
@@ -361,6 +371,24 @@ static long v4l2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 	} else
 		ret = -ENOTTY;
 
+	if (ret == 0 && cmd == VIDIOC_ENUMINPUT) {
+
+		__u32 status;
+
+		if (copy_from_user(&status, (char *)arg +
+		    offsetof(struct v4l2_input, status), sizeof(status)))
+			ret = -EFAULT;
+
+		if (v4l_vflip)
+			status ^= V4L2_IN_ST_VFLIP;
+		if (v4l_hflip)
+			status ^= V4L2_IN_ST_HFLIP;
+
+		if (copy_to_user((char *)arg + offsetof(struct v4l2_input,
+		    status), &status, sizeof(status)))
+			ret = -EFAULT;
+	}
+
 	return ret;
 }
 
@@ -447,13 +475,17 @@ static int v4l2_release(struct inode *inode, struct file *filp)
 	 * request at the same time.
 	 */
 	if (vdev->fops->release) {
+#if IS_ENABLED(MEDIA_CONTROLLER)
 		if (v4l2_device_supports_requests(vdev->v4l2_dev)) {
 			mutex_lock(&vdev->v4l2_dev->mdev->req_queue_mutex);
 			ret = vdev->fops->release(filp);
 			mutex_unlock(&vdev->v4l2_dev->mdev->req_queue_mutex);
 		} else {
+#endif
 			ret = vdev->fops->release(filp);
+#if IS_ENABLED(MEDIA_CONTROLLER)
 		}
+#endif
 	}
 
 	if (vdev->dev_debug & V4L2_DEV_DEBUG_FOP)
diff --git a/drivers/media/v4l2-core/v4l2-ioctl.c b/drivers/media/v4l2-core/v4l2-ioctl.c
index eeff398fbdcc..6f1a742ec0fa 100644
--- a/drivers/media/v4l2-core/v4l2-ioctl.c
+++ b/drivers/media/v4l2-core/v4l2-ioctl.c
@@ -2945,6 +2945,7 @@ static long __video_do_ioctl(struct file *file,
 	 * operation, and that should not be mixed with queueing a new
 	 * request at the same time.
 	 */
+#if IS_ENABLED(MEDIA_CONTROLLER)
 	if (v4l2_device_supports_requests(vfd->v4l2_dev) &&
 	    (cmd == VIDIOC_STREAMON || cmd == VIDIOC_STREAMOFF)) {
 		req_queue_lock = &vfd->v4l2_dev->mdev->req_queue_mutex;
@@ -2952,6 +2953,7 @@ static long __video_do_ioctl(struct file *file,
 		if (mutex_lock_interruptible(req_queue_lock))
 			return -ERESTARTSYS;
 	}
+#endif
 
 	lock = v4l2_ioctl_get_lock(vfd, vfh, cmd, arg);
 
diff --git a/drivers/media/v4l2-core/v4l2-subdev.c b/drivers/media/v4l2-core/v4l2-subdev.c
index a7d508e74d6b..c787cd84b4d0 100644
--- a/drivers/media/v4l2-core/v4l2-subdev.c
+++ b/drivers/media/v4l2-core/v4l2-subdev.c
@@ -428,6 +428,7 @@ static long subdev_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 
 		return v4l2_event_dequeue(vfh, arg, file->f_flags & O_NONBLOCK);
 
+#ifdef CONFIG_COMPAT_32BIT_TIME
 	case VIDIOC_DQEVENT_TIME32: {
 		struct v4l2_event_time32 *ev32 = arg;
 		struct v4l2_event ev = { };
@@ -451,7 +452,7 @@ static long subdev_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 
 		return rval;
 	}
-
+#endif
 	case VIDIOC_SUBSCRIBE_EVENT:
 		return v4l2_subdev_call(sd, core, subscribe_event, vfh, arg);
 
diff --git a/include/media/v4l2-device.h b/include/media/v4l2-device.h
index 64ec4de948e9..39b02fcfa538 100644
--- a/include/media/v4l2-device.h
+++ b/include/media/v4l2-device.h
@@ -246,11 +246,13 @@ static inline void v4l2_subdev_notify(struct v4l2_subdev *sd,
  *
  * @v4l2_dev: pointer to struct v4l2_device
  */
+#if IS_ENABLED(MEDIA_CONTROLLER)
 static inline bool v4l2_device_supports_requests(struct v4l2_device *v4l2_dev)
 {
 	return v4l2_dev->mdev && v4l2_dev->mdev->ops &&
 	       v4l2_dev->mdev->ops->req_queue;
 }
+#endif
 
 /* Helper macros to iterate over all subdevs. */
 
diff --git a/include/uapi/asm-generic/ioctl.h b/include/uapi/asm-generic/ioctl.h
index a84f4db8a250..6695939fb2d4 100644
--- a/include/uapi/asm-generic/ioctl.h
+++ b/include/uapi/asm-generic/ioctl.h
@@ -83,6 +83,7 @@
  * means userland is reading and kernel is writing.
  */
 #define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)
+#define _IOWINT(type,nr)	_IOC(_IOC_NONE,(type),(nr),sizeof(int))
 #define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
 #define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
 #define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
diff --git a/include/uapi/linux/dvb/ca.h b/include/uapi/linux/dvb/ca.h
index dffa59e95ebb..c4533a16d93e 100644
--- a/include/uapi/linux/dvb/ca.h
+++ b/include/uapi/linux/dvb/ca.h
@@ -134,9 +134,17 @@ struct ca_descr {
 
 #define CA_RESET          _IO('o', 128)
 #define CA_GET_CAP        _IOR('o', 129, struct ca_caps)
+/*
+ * At least CA_GET_SLOT_INFO and CA_GET_MSG need to be _IOWR not _IOR.
+ * This is wrong on Linux too but there the driver doesn't care.
+ *
 #define CA_GET_SLOT_INFO  _IOR('o', 130, struct ca_slot_info)
 #define CA_GET_DESCR_INFO _IOR('o', 131, struct ca_descr_info)
 #define CA_GET_MSG        _IOR('o', 132, struct ca_msg)
+*/
+#define CA_GET_SLOT_INFO  _IOWR('o', 130, struct ca_slot_info)
+#define CA_GET_DESCR_INFO _IOR('o', 131, struct ca_descr_info)
+#define CA_GET_MSG        _IOWR('o', 132, struct ca_msg)
 #define CA_SEND_MSG       _IOW('o', 133, struct ca_msg)
 #define CA_SET_DESCR      _IOW('o', 134, struct ca_descr)
 
diff --git a/include/uapi/linux/dvb/frontend.h b/include/uapi/linux/dvb/frontend.h
index 4f9b4551c534..a5e950404072 100644
--- a/include/uapi/linux/dvb/frontend.h
+++ b/include/uapi/linux/dvb/frontend.h
@@ -908,7 +908,8 @@ struct dtv_properties {
 #define FE_DISHNETWORK_SEND_LEGACY_CMD _IO('o', 80) /* unsigned int */
 
 #define FE_SET_PROPERTY		   _IOW('o', 82, struct dtv_properties)
-#define FE_GET_PROPERTY		   _IOR('o', 83, struct dtv_properties)
+#define FE_GET_PROPERTY		   _IOW('o', 83, struct dtv_properties)
+#define FE_GET_PROPERTY_OLD	   _IOR('o', 83, struct dtv_properties)
 
 #if defined(__DVB_CORE__) || !defined(__KERNEL__)
 
diff --git a/include/uapi/linux/input.h b/include/uapi/linux/input.h
index 9a61c28ed3ae..94cc0a7cb0a5 100644
--- a/include/uapi/linux/input.h
+++ b/include/uapi/linux/input.h
@@ -131,8 +131,12 @@ struct input_mask {
 #define EVIOCGREP		_IOR('E', 0x03, unsigned int[2])	/* get repeat settings */
 #define EVIOCSREP		_IOW('E', 0x03, unsigned int[2])	/* set repeat settings */
 
-#define EVIOCGKEYCODE		_IOR('E', 0x04, unsigned int[2])        /* get keycode */
-#define EVIOCGKEYCODE_V2	_IOR('E', 0x04, struct input_keymap_entry)
+/*
+ * These two need to be _IOWR not _IOR (they're wrong on Linux too but
+ * there the driver doesn't care.)
+ */
+#define EVIOCGKEYCODE		_IOWR('E', 0x04, unsigned int[2])       /* get keycode */
+#define EVIOCGKEYCODE_V2	_IOWR('E', 0x04, struct input_keymap_entry)
 #define EVIOCSKEYCODE		_IOW('E', 0x04, unsigned int[2])        /* set keycode */
 #define EVIOCSKEYCODE_V2	_IOW('E', 0x04, struct input_keymap_entry)
 
@@ -165,7 +169,7 @@ struct input_mask {
  *
  * If the request code is not an ABS_MT value, -EINVAL is returned.
  */
-#define EVIOCGMTSLOTS(len)	_IOC(_IOC_READ, 'E', 0x0a, len)
+#define EVIOCGMTSLOTS(len)	_IOC(_IOC_READ|_IOC_WRITE, 'E', 0x0a, len)
 
 #define EVIOCGKEY(len)		_IOC(_IOC_READ, 'E', 0x18, len)		/* get global key state */
 #define EVIOCGLED(len)		_IOC(_IOC_READ, 'E', 0x19, len)		/* get all LEDs */
@@ -177,11 +181,11 @@ struct input_mask {
 #define EVIOCSABS(abs)		_IOW('E', 0xc0 + (abs), struct input_absinfo)	/* set abs value/limits */
 
 #define EVIOCSFF		_IOW('E', 0x80, struct ff_effect)	/* send a force effect to a force feedback device */
-#define EVIOCRMFF		_IOW('E', 0x81, int)			/* Erase a force effect */
+#define EVIOCRMFF		_IOWINT('E', 0x81)			/* Erase a force effect */
 #define EVIOCGEFFECTS		_IOR('E', 0x84, int)			/* Report number of effects playable at the same time */
 
-#define EVIOCGRAB		_IOW('E', 0x90, int)			/* Grab/Release device */
-#define EVIOCREVOKE		_IOW('E', 0x91, int)			/* Revoke device access */
+#define EVIOCGRAB		_IOWINT('E', 0x90)			/* Grab/Release device */
+#define EVIOCREVOKE		_IOWINT('E', 0x91)			/* Revoke device access */
 
 /**
  * EVIOCGMASK - Retrieve current event mask
@@ -212,7 +216,7 @@ struct input_mask {
  * if the receive-buffer points to invalid memory, or EINVAL if the kernel
  * does not implement the ioctl.
  */
-#define EVIOCGMASK		_IOR('E', 0x92, struct input_mask)	/* Get event-masks */
+#define EVIOCGMASK		_IOW('E', 0x92, struct input_mask)	/* Get event-masks */
 
 /**
  * EVIOCSMASK - Set event mask
-- 
2.29.2

diff --git a/drivers/input/touchscreen/egalax_ts.c b/drivers/input/touchscreen/egalax_ts.c
index 83ac8c128192..b5717c4f8cd0 100644
--- a/drivers/input/touchscreen/egalax_ts.c
+++ b/drivers/input/touchscreen/egalax_ts.c
@@ -24,7 +24,9 @@
 #include <linux/slab.h>
 #include <linux/bitops.h>
 #include <linux/input/mt.h>
+#if IS_ENABLED(CONFIG_OF)
 #include <linux/of_gpio.h>
+#endif
 
 /*
  * Mouse Mode: some panel may configure the controller to mouse mode,
@@ -119,6 +121,7 @@ static irqreturn_t egalax_ts_interrupt(int irq, void *dev_id)
 /* wake up controller by an falling edge of interrupt gpio.  */
 static int egalax_wake_up_device(struct i2c_client *client)
 {
+#if IS_ENABLED(CONFIG_OF)
 	struct device_node *np = client->dev.of_node;
 	int gpio;
 	int ret;
@@ -147,6 +150,9 @@ static int egalax_wake_up_device(struct i2c_client *client)
 	gpio_free(gpio);
 
 	return 0;
+#else
+	return -ENODEV;
+#endif
 }
 
 static int egalax_firmware_version(struct i2c_client *client)
@@ -260,17 +266,21 @@ static int __maybe_unused egalax_ts_resume(struct device *dev)
 
 static SIMPLE_DEV_PM_OPS(egalax_ts_pm_ops, egalax_ts_suspend, egalax_ts_resume);
 
+#if IS_ENABLED(CONFIG_OF)
 static const struct of_device_id egalax_ts_dt_ids[] = {
 	{ .compatible = "eeti,egalax_ts" },
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, egalax_ts_dt_ids);
+#endif
 
 static struct i2c_driver egalax_ts_driver = {
 	.driver = {
 		.name	= "egalax_ts",
 		.pm	= &egalax_ts_pm_ops,
+#if IS_ENABLED(CONFIG_OF)
 		.of_match_table	= egalax_ts_dt_ids,
+#endif
 	},
 	.id_table	= egalax_ts_id,
 	.probe		= egalax_ts_probe,
